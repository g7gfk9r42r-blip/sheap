{
  "name": "leaflets",
  "version": "1.0.0",
  "private": true,
  "type": "module",
  "description": "Tools to download leaflet pages and generate PDFs",
  "author": "",
  "license": "ISC",
  "scripts": {
    "leaflet": "node download_marktguru_leaflet.mjs",
    "batch": "node batch_leaflets.mjs",
    "penny:w44": "npm run leaflet -- 4066629 ../../media/prospekte/penny/2025/W44"
  },
  "dependencies": {
    "fs-extra": "^11.2.0",
    "puppeteer": "^22.15.0"
  }
}
#!/usr/bin/env node
// Robust Marktguru leaflet downloader
// Usage:
//   npm run leaflet -- <LEAFLET_ID> <OUT_DIR> [--max 300] [--headful] [--delay 250] [--debug]

import fs from "fs-extra";
import path from "path";
import { fileURLToPath } from "url";
import crypto from "crypto";
import { spawn } from "child_process";
import puppeteer from "puppeteer";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

function sha1(buf) {
  return crypto.createHash("sha1").update(buf).digest("hex");
}

function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

function log(...a){ console.log(...a); }
function warn(...a){ console.warn(...a); }

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// CLI args
const argv = process.argv.slice(2);
if (argv.length < 2) {
  console.error("Usage: node download_marktguru_leaflet.mjs <LEAFLET_ID> <OUT_DIR> [--max 300] [--headful] [--delay 250] [--debug]");
  process.exit(1);
}
const LEAFLET_ID = String(argv[0]).trim();
const OUT_DIR = path.resolve(argv[1]);
const MAX_PAGES = Number((argv.find(a=>a=="--max") ? argv[argv.indexOf("--max")+1] : 300)) || 300;
const DELAY = Number((argv.find(a=>a=="--delay") ? argv[argv.indexOf("--delay")+1] : 250)) || 250;
const HEADFUL = argv.includes("--headful");
const DEBUG = argv.includes("--debug");

const BASE_URL = `https://www.marktguru.de/leaflets/${LEAFLET_ID}`;

// Paths
const pagesDir = path.join(OUT_DIR, "pages");
const pdfPath = path.join(OUT_DIR, `leaflet_${LEAFLET_ID}.pdf`);

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Utilities
async function ensureDirs(){
  await fs.ensureDir(OUT_DIR);
  await fs.ensureDir(pagesDir);
}

function extFromContentType(ct){
  if (!ct) return ".bin";
  ct = ct.toLowerCase();
  if (ct.includes("image/webp")) return ".webp";
  if (ct.includes("image/jpeg")) return ".jpg";
  if (ct.includes("image/png")) return ".png";
  return ".img";
}

async function saveDebug(pageIndex, html, screenshotBuf){
  if (!DEBUG) return;
  const dbgDir = path.join(OUT_DIR, "debug");
  await fs.ensureDir(dbgDir);
  if (html) await fs.writeFile(path.join(dbgDir, `page_${String(pageIndex).padStart(3,"0")}.html`), html, "utf8");
  if (screenshotBuf) await fs.writeFile(path.join(dbgDir, `page_${String(pageIndex).padStart(3,"0")}.png`), screenshotBuf);
}

async function makePdfFromImages(){
  // prefer ImageMagick's `magick` if available; fallback to Ghostscript; else skip
  const images = (await fs.readdir(pagesDir))
    .filter(n=>n.match(/^p\d+\.(webp|jpe?g|png)$/i))
    .sort();
  if (!images.length){
    warn("âš ï¸  Keine Bildseiten gefunden â€“ PDF wird nicht erzeugt.");
    return false;
  }

  // Try: magick <imgs> out.pdf
  const magick = spawn("magick", [...images.map(n=>path.join(pagesDir,n)), pdfPath], { stdio: "inherit" });
  const ok = await new Promise(res=>{
    magick.on("error", ()=>res(false));
    magick.on("exit", code=>res(code===0));
  });

  if (ok){
    log(`âœ… Fertig: ${path.relative(process.cwd(), pdfPath)}`);
    return true;
  }

  // Fallback: ghostscript (convert images to PDF pages)
  warn("â„¹ï¸  Fallback auf Ghostscript â€¦");
  const parts = images.map(n=>path.join(pagesDir,n));
  // Simple approach: run "gs" with image-to-pdf is non-trivial; skip if unavailable
  const gs = spawn("gs", [
    "-dBATCH","-dNOPAUSE","-sDEVICE=pdfwrite",
    `-sOutputFile=${pdfPath}`,
    ...parts
  ], { stdio: "inherit" });
  const ok2 = await new Promise(res=>{
    gs.on("error", ()=>res(false));
    gs.on("exit", code=>res(code===0));
  });
  if (ok2){
    log(`âœ… Fertig (gs): ${path.relative(process.cwd(), pdfPath)}`);
    return true;
  }

  warn("âš ï¸  Konnte kein PDF erzeugen (weder magick noch gs erfolgreich).");
  return false;
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Main
(async () => {
  await ensureDirs();
  log(`ğŸš€ Starte Download fÃ¼r Leaflet ${LEAFLET_ID}`);

  const browser = await puppeteer.launch({
    headless: !HEADFUL,
    args: [
      "--no-sandbox","--disable-setuid-sandbox",
      "--disable-dev-shm-usage","--disable-blink-features=AutomationControlled",
    ]
  });

  let downloaded = 0;
  try {
    const page = await browser.newPage();
    await page.setUserAgent(
      "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36"
    );
    await page.setViewport({ width: 1366, height: 900, deviceScaleFactor: 1 });

    // Prime session + accept cookies if present
    await page.goto(BASE_URL, { waitUntil: "domcontentloaded", timeout: 60000 });
    try {
      // Try to click cookie banner common selectors
      const cookieBtn = await page.$x("//button[contains(., 'Akzeptieren') or contains(., 'Einverstanden') or contains(., 'Alle akzeptieren')]");
      if (cookieBtn.length) { await cookieBtn[0].click().catch(()=>{}); }
    } catch {}

    // Download loop: try sequential pages until a small sequence of misses
    let consecutiveMisses = 0;
    const MAX_MISSES = 3; // allow a few holes before stopping

    for (let i = 0; i < MAX_PAGES; i++) {
      const fnBase = `p${String(i).padStart(3, "0")}`;

      // Skip if already downloaded
      const existing = (await fs.readdir(pagesDir)).find(n => n.startsWith(fnBase + ".") && n.match(/\.(png|jpe?g|webp)$/));
      if (existing) {
        log(`â­ï¸  Seite ${i} existiert bereits, Ã¼berspringe (${existing})`);
        downloaded++;
        consecutiveMisses = 0;
        continue;
      }

      log(`ğŸ“„ Lade Seite ${i} ...`);

      // Try direct image endpoint first
      const imgUrl = `${BASE_URL}/page/${i}`; // HTML page
      await page.goto(imgUrl, { waitUntil: "domcontentloaded", timeout: 60000 }).catch(()=>{});

      // Give the page a moment to render lazy content
      await sleep(DELAY);

      // Try to detect the main image element (common patterns)
      const result = await page.evaluate(() => {
        const pick = () => {
          const candidates = Array.from(document.querySelectorAll('img, source, picture img'));
          // Prefer biggest images
          candidates.sort((a,b)=> (b.naturalWidth*b.naturalHeight) - (a.naturalWidth*a.naturalHeight));
          for (const el of candidates){
            const src = el.getAttribute('src') || el.getAttribute('data-src') || '';
            if (!src) continue;
            if (/leaflets\/.+\/(page|image)\//.test(src) || /\/images\//.test(src) || /cdn/.test(src)) {
              return src;
            }
          }
          return candidates[0]?.getAttribute('src') || candidates[0]?.getAttribute('data-src') || null;
        };
        return pick();
      });

      if (!result) {
        // Save debug info
        const html = await page.content().catch(()=>"");
        const png = await page.screenshot({ fullPage: true }).catch(()=>null);
        await saveDebug(i, html, png);
        warn(`âŒ Kein Bild gefunden, Stop bei Seite ${i}`);
        consecutiveMisses++;
        if (consecutiveMisses >= MAX_MISSES) break;
        else continue;
      }

      // Resolve relative URL
      const imgSrc = new URL(result, page.url()).href;

      // Fetch the image bytes with proper headers
      const buf = await page.evaluate(async (href) => {
        const res = await fetch(href, {
          headers: {
            "Accept": "image/avif,image/webp,image/apng,image/*,*/*;q=0.8",
            "Referer": location.href,
            "Cache-Control": "no-cache"
          },
          credentials: "include"
        });
        if (!res.ok) throw new Error("HTTP " + res.status);
        const ab = await res.arrayBuffer();
        const ct = res.headers.get("content-type") || "";
        return { bytes: Array.from(new Uint8Array(ab)), ct };
      }, imgSrc).catch(async (e) => {
        // Save debug and continue
        const html = await page.content().catch(()=>"");
        const png = await page.screenshot({ fullPage: true }).catch(()=>null);
        await saveDebug(i, html, png);
        warn(`âŒ Fehler beim Laden von Seite ${i}: ${e.message}`);
        consecutiveMisses++;
        if (consecutiveMisses >= MAX_MISSES) return null;
        return null;
      });

      if (!buf) break; // too many misses

      const bytes = Buffer.from(buf.bytes);
      const ct = buf.ct;
      const ext = extFromContentType(ct);
      const fn = path.join(pagesDir, `${fnBase}${ext}`);

      await fs.writeFile(fn, bytes);

      // Hashing & duplicate hint
      const hash = sha1(bytes);
      const hashFile = path.join(pagesDir, `${fnBase}.sha1`);
      const prev = await fs.pathExists(hashFile) ? (await fs.readFile(hashFile, "utf8")).trim() : null;
      await fs.writeFile(hashFile, hash);
      if (prev && prev === hash) {
        warn(`âš ï¸  Seite ${i}: identisch zu vorherigem Hash â€“ mÃ¶gliches Duplikat.`);
      }

      log(`âœ… Seite ${i} gespeichert (${path.relative(process.cwd(), fn)})`);
      downloaded++;
      consecutiveMisses = 0;

      await sleep(DELAY);
    }

  } finally {
    await browser.close().catch(()=>{});
  }

  if (!downloaded) {
    warn("âŒ Keine Seiten geladen â€“ PDF wird Ã¼bersprungen.");
    process.exit(2);
  }

  log("ğŸ§© Erstelle PDF â€¦");
  await makePdfFromImages();
  log(`â„¹ï¸ Insgesamt ${downloaded} Seiten heruntergeladen und als PDF gespeichert.`);
})();
